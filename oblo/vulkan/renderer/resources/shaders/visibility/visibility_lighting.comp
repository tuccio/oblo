#version 460

#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : require

#extension GL_EXT_debug_printf : require

#include <renderer/camera>
#include <renderer/debug>
#include <renderer/instances>
#include <renderer/lights>
#include <renderer/material>
#include <renderer/meshes>
#include <renderer/textures>
#include <renderer/volumes>
#include <visibility/visibility_buffer>

layout(local_size_x = OBLO_SUBGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform b_CameraBuffer
{
    camera_buffer g_Camera;
};

layout(binding = 1) uniform b_LightConfig
{
    light_config g_LightConfig;
};

layout(std430, binding = 2) restrict readonly buffer b_LightData
{
    light_data lights[];
};

layout(binding = 10) uniform texture2D t_InDepthBuffer;

layout(binding = 11, rg32ui) uniform restrict readonly uimage2D t_InVisibilityBuffer;

layout(binding = 12, rgba8) uniform restrict writeonly image2D t_OutLitImage;

layout(push_constant) uniform c_PushConstants
{
    uvec2 resolution;
}
g_Constants;

void main()
{
    if (gl_GlobalInvocationID.x >= g_Constants.resolution.x)
    {
        return;
    }

    const ivec2 screenPos = ivec2(gl_GlobalInvocationID.xy);

    const float depth = texelFetch(t_InDepthBuffer, screenPos, 0).x;
    // debugPrintfEXT("[%d, %d] depth %f\n", screenPos.x, screenPos.y, depth);

    if (camera_depth_no_hit(depth))
    {
        imageStore(t_OutLitImage, screenPos, vec4(0));
        return;
    }

    const uvec4 visBufferData = imageLoad(t_InVisibilityBuffer, screenPos);

    visibility_buffer_data vb;

    visibility_buffer_parse(visBufferData.xy, vb);

    // if (!visibility_buffer_parse(visBufferData.xy, vb))
    // {
    //     imageStore(t_OutLitImage, screenPos, vec4(0));
    //     return;
    // }

    imageStore(t_OutLitImage, screenPos, vec4(debug_color_map(vb.triangleIndex), 1));
    return;

    const mesh_handle mesh = OBLO_INSTANCE_DATA(vb.instanceTableId, i_MeshHandles, vb.instanceId);
    const mesh_table meshTable = mesh_table_fetch(mesh);

    vec3 vPosition[3];
    vec3 vNormal[3];
    vec2 vUV0[3];

    // Alternative for position: reconstruct from depth buffer?

    for (uint i = 0; i < 3; ++i)
    {
        // Can skip if no index buffer, then triangle index is vertex index
        // const uint vertexId = mesh_table_triangle_index(meshTable, vb.triangleIndex, i); // TODO
        const uint vertexId = 0;

        vPosition[i] = mesh_get_position(meshTable, vertexId);
        vNormal[i] = mesh_get_normal(meshTable, vertexId);
        vUV0[i] = mesh_get_uv0(meshTable, vertexId);
    }

    // Interpolate with barycentric coordinates
    vec3 positionWS = vPosition[0]; // Actually need to transform it too?
    vec3 normal = vNormal[0];
    vec2 uv0 = vUV0[0];

    const gpu_material material = OBLO_INSTANCE_DATA(vb.instanceTableId, i_MaterialBuffer, vb.instanceId);

    // TODO: We need to calculate the LOD ourselves
    const vec4 color = texture_sample_2d(material.albedoTexture, OBLO_SAMPLER_LINEAR, uv0);

    vec3 reflected = vec3(0);

    for (uint lightIndex = 0; lightIndex < g_LightConfig.lightsCount; ++lightIndex)
    {
        reflected += light_contribution(lights[lightIndex], positionWS, normal);
    }

    const vec4 final = vec4(color.xyz * material.albedo * reflected, 1);

    imageStore(t_OutLitImage, screenPos, final);
}