#version 460

#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_quad : require

#extension GL_EXT_debug_printf : require

#include <renderer/barycentric>
#include <renderer/camera>
#include <renderer/debug>
#include <renderer/instances>
#include <renderer/lights>
#include <renderer/material>
#include <renderer/math>
#include <renderer/meshes>
#include <renderer/raytrace>
#include <renderer/textures>
#include <renderer/transform>
#include <renderer/volumes>
#include <visibility/visibility_buffer>

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform b_CameraBuffer
{
    camera_buffer g_Camera;
};

layout(binding = 1) uniform b_LightConfig
{
    light_config g_LightConfig;
};

layout(std430, binding = 2) restrict readonly buffer b_LightData
{
    light_data lights[];
};

layout(binding = 10) uniform texture2D t_InDepthBuffer;

layout(binding = 11, rg32ui) uniform restrict readonly uimage2D t_InVisibilityBuffer;

layout(binding = 12, rgba8) uniform restrict writeonly image2D t_OutLitImage;

layout(binding = 25, rgba32f) uniform restrict readonly image2D t_InDebugBuffer;

layout(push_constant) uniform c_PushConstants
{
    uvec2 resolution;
}
g_Constants;

// Source:
// https://github.com/GPUOpen-Effects/FidelityFX-Denoiser/blob/master/ffx-shadows-dnsr/ffx_denoiser_shadows_util.h
//  LANE TO 8x8 MAPPING
//  ===================
//  00 01 08 09 10 11 18 19
//  02 03 0a 0b 12 13 1a 1b
//  04 05 0c 0d 14 15 1c 1d
//  06 07 0e 0f 16 17 1e 1f
//  20 21 28 29 30 31 38 39
//  22 23 2a 2b 32 33 3a 3b
//  24 25 2c 2d 34 35 3c 3d
//  26 27 2e 2f 36 37 3e 3f
uint bitfield_extract(uint src, uint off, uint bits)
{
    uint mask = (1u << bits) - 1;
    return (src >> off) & mask;
} // ABfe

uint bitfield_insert(uint src, uint ins, uint bits)
{
    uint mask = (1u << bits) - 1;
    return (ins & mask) | (src & (~mask));
} // ABfiM

uvec2 remap_lane_8x8(uint lane)
{
    return uvec2(bitfield_insert(bitfield_extract(lane, 2u, 3u), lane, 1u),
        bitfield_insert(bitfield_extract(lane, 3u, 3u), bitfield_extract(lane, 1u, 2u), 2u));
}

void main()
{
    const uvec2 localGroupId = remap_lane_8x8(gl_LocalInvocationIndex);
    const ivec2 screenPos = ivec2(gl_WorkGroupID.xy * 8 + localGroupId);

    if (screenPos.x >= g_Constants.resolution.x || screenPos.y >= g_Constants.resolution.y)
    {
        return;
    }

    const float depth = texelFetch(t_InDepthBuffer, screenPos, 0).x;
    const vec4 debugRead = imageLoad(t_InDebugBuffer, screenPos);
    // debugPrintfEXT("[%d, %d] depth %f\n", screenPos.x, screenPos.y, depth);

    if (camera_depth_no_hit(depth))
    {
        imageStore(t_OutLitImage, screenPos, vec4(0));
        return;
    }

    const vec2 positionNDC = vec2(2 * screenPos) / g_Constants.resolution - 1.f;
    // const vec4 positionVSh = g_Camera.invProjection * vec4(positionNDC.xy, depth, 1);
    // const vec3 positionVS = vec3(positionVSh.xy, positionVSh.z / positionVSh.w);

    vec3 actualPositionWS = camera_unproject_world_space(g_Camera, positionNDC, depth);
    vec3 positionWS = actualPositionWS;

    const uvec4 visBufferData = imageLoad(t_InVisibilityBuffer, screenPos);

    visibility_buffer_data vb;

    visibility_buffer_parse(visBufferData.xy, vb);

    // if (!visibility_buffer_parse(visBufferData.xy, vb))
    // {
    //     imageStore(t_OutLitImage, screenPos, vec4(0));
    //     return;
    // }

    // debugPrintfEXT("Z: %f\n", positionVS.z );

    // imageStore(t_OutLitImage, screenPos, vec4(debug_color_map(vb.triangleIndex), 1));
    // imageStore(t_OutLitImage, screenPos, vec4(debug_color_map(vb.triangleIndex / 100000.f), 1));

    const mesh_handle mesh = OBLO_INSTANCE_DATA(vb.instanceTableId, i_MeshHandles, vb.instanceId);
    const transform transform = OBLO_INSTANCE_DATA(vb.instanceTableId, i_TransformBuffer, vb.instanceId);
    const mesh_table meshTable = mesh_table_fetch(mesh);

    triangle triangleWS;
    vec2 triangleUV0[3];
    vec3 triangleNormalWS[3];

    uint vertexIndices[3];
    mesh_get_vertex_indices(meshTable, vb.triangleIndex, vertexIndices);

    for (uint i = 0; i < 3; ++i)
    {
        const uint vertexId = vertexIndices[i];

        const vec3 vertexPosition = mesh_get_position(meshTable, vertexId);
        triangleWS.v[i] = (transform.localToWorld * vec4(vertexPosition, 1)).xyz;

        const vec3 vertexNormal = mesh_get_normal(meshTable, vertexId);
        triangleNormalWS[i] = vertexNormal;

        triangleUV0[i] = mesh_get_uv0(meshTable, vertexId);
    }

    const vec3 screenPosWS = camera_unproject_world_space(g_Camera, positionNDC, 0);

    ray cameraRay;
    cameraRay.origin = g_Camera.position;
    cameraRay.direction = normalize(screenPosWS - g_Camera.position);

    float intersectionDistance;
    
    if (!distance_from_triangle_plane(cameraRay, triangleWS, intersectionDistance))
    {
        imageStore(t_OutLitImage, screenPos, vec4(0));
        return;
    }

    ray cameraRayDDX;
    cameraRayDDX.origin = g_Camera.position;
    cameraRayDDX.direction = subgroupQuadSwapHorizontal(cameraRay.direction);

    float intersectionDistanceDDX;
    distance_from_triangle_plane(cameraRayDDX, triangleWS, intersectionDistanceDDX);

    ray cameraRayDDY;
    cameraRayDDY.origin = g_Camera.position;
    cameraRayDDY.direction = subgroupQuadSwapVertical(cameraRay.direction);

    float intersectionDistanceDDY;
    distance_from_triangle_plane(cameraRayDDX, triangleWS, intersectionDistanceDDY);

    positionWS = ray_point_at(cameraRay, intersectionDistance);
    const vec3 positionDDX = ray_point_at(cameraRayDDX, intersectionDistanceDDX);
    const vec3 positionDDY = ray_point_at(cameraRayDDY, intersectionDistanceDDY);

    // if (screenPos == ivec2(800, 300))
    // {
    //     // debugPrintfEXT("POSX: %f %f %f\n", positionWS.x, positionWS.y, positionWS.z);
    //     // debugPrintfEXT("POSDDX: %f %f %f\n", positionDDX.x, positionDDX.y, positionDDX.z);
    //     // debugPrintfEXT("POSDDY: %f %f %f\n", positionDDY.x, positionDDY.y, positionDDY.z);
    //     imageStore(t_OutLitImage, screenPos, vec4(1, 0, 0, 1));
    //     return;
    // }

    barycentric_coords bc;
    barycentric_calculate(bc, triangleWS.v, positionWS);

    barycentric_coords bcDDX;
    barycentric_calculate(bcDDX, triangleWS.v, positionDDX);
    // bcDDX.lambda = subgroupQuadSwapHorizontal(bc.lambda);

    barycentric_coords bcDDY;
    barycentric_calculate(bcDDX, triangleWS.v, positionDDY);
    // bcDDY.lambda = subgroupQuadSwapVertical(bc.lambda);

    const vec2 uv0 = barycentric_interpolate(bc, triangleUV0);

    const vec2 uv0QuadX = barycentric_interpolate(bcDDX, triangleUV0);
    const vec2 uv0QuadY = barycentric_interpolate(bcDDY, triangleUV0);

    const vec2 uv0DDX = uv0 - uv0QuadX;
    const vec2 uv0DDY = uv0 - uv0QuadY;

    const vec3 normalWS = barycentric_interpolate(bc, triangleNormalWS);

    const vec3 debugWS = barycentric_interpolate(bc, triangleWS.v);

    if (bcDDX.lambda.x >= 0.f && bcDDX.lambda.y >= 0.f && bcDDX.lambda.z >= 0.f ||
        bcDDY.lambda.x >= 0.f && bcDDY.lambda.y >= 0.f && bcDDY.lambda.z >= 0.f)
    {
        imageStore(t_OutLitImage, screenPos, vec4(0));

            //    debugPrintfEXT("Expected [%f %f %f] got [%f %f %f]\n",
            // actualPositionWS.x,
            // actualPositionWS.y,
            // actualPositionWS.z,
            // positionWS.x,
            // positionWS.y,
            // positionWS.z);
        // return;
    }
    else
    {
        // debugPrintfEXT("Expected [%f %f %f] got [%f %f %f]\n",
        //     actualPositionWS.x,
        //     actualPositionWS.y,
        //     actualPositionWS.z,
        //     positionWS.x,
        //     positionWS.y,
        //     positionWS.z);
    }

    // imageStore(t_OutLitImage, screenPos, vec4((debugWS.z - positionWS.z), 0, 0, 1));
    // imageStore(t_OutLitImage, screenPos, vec4(debug_color_map(positionWS.z / 5.f), 1));
    // imageStore(t_OutLitImage, screenPos, vec4(debug_color_map(debugWS.z / 5.f), 1));
    // imageStore(t_OutLitImage, screenPos, vec4(debug_color_map(depth), 1));
    // imageStore(t_OutLitImage, screenPos, debugRead);
    // imageStore(t_OutLitImage, screenPos, vec4(uv0.xy, 0, 1));

    // return;

    // const mesh_handle mesh = OBLO_INSTANCE_DATA(vb.instanceTableId, i_MeshHandles, vb.instanceId);
    // const mesh_table meshTable = mesh_table_fetch(mesh);

    // vec3 vNormal[3];
    // vec2 vUV0[3];

    // uint vertexIndices[3];
    // mesh_get_vertex_indices(meshTable, vb.triangleIndex, vertexIndices);

    // for (uint i = 0; i < 3; ++i)
    // {
    //     const uint vertexId = vertexIndices[i];

    //     vNormal[i] = mesh_get_normal(meshTable, vertexId);
    //     vUV0[i] = mesh_get_uv0(meshTable, vertexId);
    // }

    // // Interpolate with barycentric coordinates
    // vec3 normalVS = vNormal[0];
    // vec2 uv0 = vUV0[0];

    const gpu_material material = OBLO_INSTANCE_DATA(vb.instanceTableId, i_MaterialBuffer, vb.instanceId);

    // const vec4 color = texture_sample_2d_lod(material.albedoTexture, OBLO_SAMPLER_LINEAR, uv0, 0);
    const vec4 color = texture_sample_2d_grad(material.albedoTexture, OBLO_SAMPLER_LINEAR, uv0, uv0DDX, uv0DDY);

    vec3 reflected = vec3(0);

    for (uint lightIndex = 0; lightIndex < g_LightConfig.lightsCount; ++lightIndex)
    {
        reflected += light_contribution(lights[lightIndex], positionWS, normalWS);
    }

    const vec4 final = vec4(color.xyz * material.albedo * reflected, 1);

    imageStore(t_OutLitImage, screenPos, final);
}