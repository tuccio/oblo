#version 460

#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_quad : require
#extension GL_EXT_control_flow_attributes : enable

#include <renderer/camera>
#include <renderer/instances>
#include <renderer/material>
#include <renderer/math>
#include <renderer/meshes/mesh_attributes>
#include <renderer/meshes/mesh_data>
#include <renderer/meshes/mesh_indices>
#include <renderer/meshes/mesh_table>
#include <renderer/shading/normal_mapping>
#include <renderer/shading/pbr>
#include <renderer/textures>
#include <renderer/transform>
#include <renderer/volumes>
#include <visibility/visibility_shading>

vec4 visibility_shade(in ivec2 screenPos, in visibility_buffer_data vb)
{
    // Read the instance data we need
    const mesh_handle mesh = OBLO_INSTANCE_DATA(vb.instanceTableId, i_MeshHandles, vb.instanceId);
    const transform transform = OBLO_INSTANCE_DATA(vb.instanceTableId, i_TransformBuffer, vb.instanceId);
    const gpu_material material = OBLO_INSTANCE_DATA(vb.instanceTableId, i_MaterialBuffer, vb.instanceId);

    triangle triangleWS;
    vec2 triangleUV0[3];
    vec3 triangleNormal[3];
    vec3 triangleTangent[3];
    vec3 triangleBitangent[3];

    // Read the mesh data
    const mesh_table meshTable = mesh_table_fetch(mesh);
    const uvec3 vertexIndices = mesh_get_meshlet_indices(meshTable, mesh, vb.meshletId, vb.meshletTriangleId);

    // Read the vertex data and transform everything in world space, we do lighting calculation in that space
    [[unroll]] for (uint i = 0; i < 3; ++i)
    {
        const uint vertexId = vertexIndices[i];

        const vec3 vertexPosition = mesh_get_position(meshTable, vertexId);
        triangleWS.v[i] = (transform.localToWorld * vec4(vertexPosition, 1)).xyz;

        triangleUV0[i] = mesh_get_uv0(meshTable, vertexId);
    }

    barycentric_coords bc, bcDDX, bcDDY;
    vec3 positionWS;

    if (!calculate_position_and_barycentric_coords(screenPos, triangleWS, positionWS, bc, bcDDX, bcDDY))
    {
        return vec4(0);
    }

    // Interpolate UV0 and calculate gradients
    const vec2 uv0 = barycentric_interpolate(bc, triangleUV0);

    vec2 uv0DDX, uv0DDY;
    barycentric_partial_derivatives(bcDDX, bcDDY, uv0, triangleUV0, uv0DDX, uv0DDY);

    vec3 albedo = material.albedo;

    if (material.albedoTexture != 0)
    {
        const vec3 sampled =
            texture_sample_2d_grad(material.albedoTexture, OBLO_SAMPLER_LINEAR, uv0, uv0DDX, uv0DDY).xyz;

        albedo *= sampled;
    }

    return vec4(albedo, 1);
}
