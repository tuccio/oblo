#version 460

#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_control_flow_attributes : enable

#include <raytracing_debug/common>
#include <renderer/camera>
#include <renderer/debug>
#include <renderer/math>
#include <renderer/meshes/mesh_table>
#include <renderer/quad>

layout(binding = 16) uniform b_CameraBuffer
{
    camera_buffer g_Camera;
};

layout(binding = 11) uniform accelerationStructureEXT u_SceneTLAS;

layout(binding = 12, rgba8) uniform restrict writeonly image2D t_OutShadedImage;

layout(push_constant) uniform c_PushConstants
{
    uvec2 resolution;
}
g_Constants;

struct rt_instance_id
{
    uint instanceTableId;
    uint instanceId;
};

rt_instance_id rt_instance_id_from_custom_index(uint customIndex)
{
    rt_instance_id r;
    r.instanceTableId = customIndex >> 20;
    r.instanceId = customIndex & ((1u << 20) - 1);
    return r;
}

layout(location = 0) rayPayloadEXT hit_payload r_HitPayload;

void main()
{
    const vec2 positionNDC = screen_to_ndc(gl_LaunchSizeEXT.xy, gl_LaunchIDEXT.xy);

    const vec3 origin = g_Camera.position;
    const vec3 direction = camera_ray_direction(g_Camera, positionNDC);

    const float tMin = 1e-2f;
    const float tMax = 1e6f;

    traceRayEXT(u_SceneTLAS,
        gl_RayFlagsOpaqueEXT,
        0xff, // cull mask
        0,    // STB record offset
        0,    // STB record stride
        0,    // Miss index
        origin,
        tMin,
        direction,
        tMax,
        0 // payload location
    );

    const vec3 color = debug_color_map(r_HitPayload.customIndex);

    imageStore(t_OutShadedImage, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}