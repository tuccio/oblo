#version 460

#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_EXT_ray_query : require
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_quad : require
#extension GL_EXT_control_flow_attributes : enable

#include <renderer/camera>
#include <renderer/debug>
#include <renderer/math>
#include <renderer/meshes/mesh_table>
#include <renderer/quad>

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(binding = 16) uniform b_CameraBuffer
{
    camera_buffer g_Camera;
};

layout(binding = 11) uniform accelerationStructureEXT as_SceneTLAS;

layout(binding = 12, rgba8) uniform restrict writeonly image2D t_OutShadedImage;

layout(push_constant) uniform c_PushConstants
{
    uvec2 resolution;
}
g_Constants;

struct rt_instance_id
{
    uint instanceTableId;
    uint instanceId;
};

rt_instance_id rt_instance_id_from_custom_index(uint customIndex)
{
    rt_instance_id r;
    r.instanceTableId = customIndex >> 20;
    r.instanceId = customIndex & ((1u << 20) - 1);
    return r;
}

void main()
{
    const uvec2 localGroupId = quad_remap_lane_8x8(gl_LocalInvocationIndex);
    const ivec2 screenPos = ivec2(gl_WorkGroupID.xy * 8 + localGroupId);

    if (screenPos.x >= g_Constants.resolution.x)
    {
        return;
    }

    vec4 color = vec4(0);

    // Initializes a ray query object but does not start traversal
    rayQueryEXT rayQuery;

    const vec3 origin = g_Camera.position;
    const vec3 direction = camera_ray_direction(g_Camera, g_Constants.resolution, screenPos);

    const float tMin = 1e-2f;
    const float tMax = 1e6f;

    rayQueryInitializeEXT(rayQuery, as_SceneTLAS, gl_RayFlagsNoneEXT, 0xff, origin, tMin, direction, tMax);

    // Start traversal: return false if traversal is complete
    while (rayQueryProceedEXT(rayQuery))
    {
        if (rayQueryGetIntersectionTypeEXT(rayQuery, false) == gl_RayQueryCandidateIntersectionTriangleEXT)
        {
            rayQueryConfirmIntersectionEXT(rayQuery);
        }
    }

    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
    {
        const uint customIndex = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
        color = vec4(debug_color_map(customIndex), 1);
    }

    imageStore(t_OutShadedImage, screenPos, color);
}