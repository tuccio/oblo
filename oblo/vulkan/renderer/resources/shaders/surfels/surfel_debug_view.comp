#version 460

#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_quad : require
#extension GL_EXT_control_flow_attributes : enable

#include <renderer/camera>
#include <renderer/debug/colors>
#include <renderer/geometry/volumes>
#include <renderer/instances>
#include <renderer/material>
#include <renderer/math/spherical_harmonics>
#include <renderer/math>
#include <renderer/meshes/mesh_attributes>
#include <renderer/meshes/mesh_data>
#include <renderer/meshes/mesh_indices>
#include <renderer/meshes/mesh_table>
#include <renderer/shading/normal_mapping>
#include <renderer/shading/pbr>
#include <renderer/textures>
#include <renderer/transform>
#include <surfels/buffers/surfel_data_r>
#include <surfels/buffers/surfel_grid_data_r>
#include <surfels/buffers/surfel_grid_r>
#include <surfels/buffers/surfel_lighting_data_in_r>
#include <surfels/surfel_data>
#include <tone_mapping/tonemap>
#include <visibility/visibility_shading>
#include <visibility/visibility_utils>

vec4 visibility_shade(in visibility_shade_context ctx)
{
    // Read the instance data we need
    const mesh_handle mesh = OBLO_INSTANCE_DATA(ctx.vb.instanceTableId, i_MeshHandles, ctx.vb.instanceId);
    const transform transform = OBLO_INSTANCE_DATA(ctx.vb.instanceTableId, i_TransformBuffer, ctx.vb.instanceId);
    const gpu_material material = OBLO_INSTANCE_DATA(ctx.vb.instanceTableId, i_MaterialBuffer, ctx.vb.instanceId);

    triangle triangleWS;
    vec3 triangleNormal[3];

    // Read the mesh data
    const mesh_table meshTable = mesh_table_fetch(mesh);
    const uvec3 vertexIndices = mesh_get_meshlet_indices(meshTable, mesh, ctx.vb.meshletId, ctx.vb.meshletTriangleId);

    // Read the vertex data and transform everything in world space, we do lighting calculation in that space
    [[unroll]] for (uint i = 0; i < 3; ++i)
    {
        const uint vertexId = vertexIndices[i];

        const vec3 vertexPosition = mesh_get_position(meshTable, vertexId);
        triangleWS.v[i] = (transform.localToWorld * vec4(vertexPosition, 1)).xyz;

        const vec3 vertexNormal = mesh_get_normal(meshTable, vertexId);
        triangleNormal[i] = vertexNormal;
    }

    barycentric_coords bc, bcDDX, bcDDY;
    vec3 positionWS;

    if (!calculate_position_and_barycentric_coords(ctx.screenPos,
            ctx.resolution,
            triangleWS,
            positionWS,
            bc,
            bcDDX,
            bcDDY))
    {
        return vec4(0);
    }

    const vec3 normalWS = barycentric_interpolate(bc, triangleNormal);

    const surfel_grid_header gridHeader = g_SurfelGridHeader;

    const ivec3 cell = surfel_grid_find_cell(gridHeader, positionWS);
    const uint cellIndex = surfel_grid_cell_index(gridHeader, cell);

    const surfel_grid_cell gridCell = g_SurfelGridCells[cellIndex];

    // Since we might have multiple surfels overlapping on the pixel, we try to keep debug views stable by choosing the
    // minimum id
    uint minSurfelId = gridHeader.maxSurfels;

    for (surfel_grid_cell_iterator cellIt = surfel_grid_cell_iterator_begin(gridCell);
         surfel_grid_cell_iterator_has_next(cellIt);
         surfel_grid_cell_iterator_advance(cellIt))
    {
        const uint surfelId = surfel_grid_cell_iterator_get(cellIt);
        const surfel_data surfel = g_SurfelData[surfelId];

        const vec3 surfelPosition = surfel_data_world_position(surfel);

        const vec3 pToS = surfelPosition - positionWS;

        const float distance2 = dot(pToS, pToS);
        const float radius2 = dot(surfel.radius, surfel.radius);

        if (distance2 <= radius2)
        {
            minSurfelId = min(minSurfelId, surfelId);
        }
    }

    if (minSurfelId < gridHeader.maxSurfels)
    {
        const uint surfelId = minSurfelId;

#if defined(MODE_SURFEL_GRID_ID)
        return vec4(debug_color_map(surfelId), 1);
#elif defined(MODE_SURFEL_LIGHTING)
        const surfel_lighting_data surfelLight = g_InSurfelsLighting[surfelId];

        const sh3 lobe = sh3_cosine_lobe_project(normalWS);

        // Integral of the product of cosine and the irradiance
        const float r = sh_dot(lobe, surfelLight.shRed);
        const float g = sh_dot(lobe, surfelLight.shGreen);
        const float b = sh_dot(lobe, surfelLight.shBlue);

        const vec3 irradiance = vec3(r, g, b);
        const vec3 radiance = irradiance / float_pi();

        return vec4(tonemap_aces_approx(radiance), 1);
#endif
    }

    return vec4(0);
}

vec4 visibility_miss(in visibility_shade_context ctx)
{
    return vec4(0, 0, 0, 1);
}