#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#include <renderer/random/random>
#include <renderer/random/sampling>
#include <surfels/buffers/surfel_buffer_bindings>
#include <surfels/buffers/surfel_data_r>
#include <surfels/buffers/surfel_grid_r>
#include <surfels/buffers/surfel_lighting_data_in_r>
#include <surfels/buffers/surfel_lighting_data_out_w>
#include <surfels/surfel_data>

layout(binding = 11) uniform accelerationStructureEXT u_SceneTLAS;

layout(location = 0) rayPayloadEXT vec3 r_HitColor;

layout(push_constant) uniform c_PushConstants
{
    uint randomSeed;
}
g_Constants;

void main()
{
    const uint surfelId = gl_LaunchIDEXT.x;
    const surfel_data surfel = g_SurfelData[surfelId];

    if (!surfel_data_is_alive(surfel))
    {
        g_OutSurfelsLighting[surfelId] = surfel_lighting_data_new();
        return;
    }

    uint randomSeed = random_seed(g_Constants.randomSeed, surfelId);

    const vec3 origin = surfel_data_world_position(surfel);
    const vec3 N = surfel_data_world_normal(surfel);
    const vec3 direction = random_sample_uniform_hemisphere(N, random_uniform_2d(randomSeed));

#if OBLO_DEBUG_PRINTF

    // debugPrintfEXT("Surfel %u should shoot a ray! [%f %f %f] -> [%f %f %f] (%f %f %f)\n",
    //     surfelId,
    //     origin.x,
    //     origin.y,
    //     origin.z,
    //     direction.x,
    //     direction.y,
    //     direction.z,
    //     N.x,
    //     N.y,
    //     N.z);

#endif

    const float tMin = 1e-2f;
    const float tMax = 1e6f;

    traceRayEXT(u_SceneTLAS,
        gl_RayFlagsOpaqueEXT,
        0xff, // cull mask
        0,    // STB record offset
        0,    // STB record stride
        0,    // Miss index
        origin,
        tMin,
        direction,
        tMax,
        0 // payload location
    );

    // TODO: Should we attenuate with distance?
    // The hit shader should attenuate in case? We should not attenuate sky light
    const sh3 shIrradiance = sh3_eval(direction);

    // g_OutSurfelsLighting[surfelId].radiance = r_HitColor;
    const sh3 r = sh_mul(shIrradiance, r_HitColor.r);
    const sh3 g = sh_mul(shIrradiance, r_HitColor.g);
    const sh3 b = sh_mul(shIrradiance, r_HitColor.b);

#if 0
    g_OutSurfelsLighting[surfelId].shRed = r;
    g_OutSurfelsLighting[surfelId].shGreen = g;
    g_OutSurfelsLighting[surfelId].shBlue = b;
#else
    const float k = .25f;

    g_OutSurfelsLighting[surfelId].shRed = sh_mix(g_InSurfelsLighting[surfelId].shRed, r, k);
    g_OutSurfelsLighting[surfelId].shGreen = sh_mix(g_InSurfelsLighting[surfelId].shGreen, g, k);
    g_OutSurfelsLighting[surfelId].shBlue = sh_mix(g_InSurfelsLighting[surfelId].shBlue, b, k);
#endif
}