#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#include <renderer/math>
#include <renderer/textures>

layout(binding = 0, rgba16f) uniform restrict readonly image2D t_InHDR;
layout(binding = 1, rgba8) uniform restrict writeonly image2D t_OutLDR;

layout(local_size_x = OBLO_SUBGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

// Simple tone mapping from "Photographic Tone Reproduction for Digital Images"
vec3 reinhard_eq3(in vec3 x)
{
    return x / (x + 1);
}

// ACES approximation from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 aces_approx(in vec3 x)
{
    const float a = 2.51f;
    const float b = 0.03f;
    const float c = 2.43f;
    const float d = 0.59f;
    const float e = 0.14f;
    return saturate((x * (a * x + b)) / (x * (c * x + d) + e));
}

vec3 tone_map(in vec3 x)
{
    return aces_approx(x);
}

void main()
{
    const uvec2 resolution = imageSize(t_InHDR);
    const ivec2 screenPos = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy);

    if (screenPos.x >= resolution.x || screenPos.y >= resolution.y)
    {
        return;
    }

    const vec4 hdr = imageLoad(t_InHDR, screenPos);
    const vec4 ldr = vec4(tone_map(hdr.xyz), hdr.w);

    imageStore(t_OutLDR, screenPos, ldr);
}