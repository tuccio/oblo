#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_ARB_gpu_shader_int64 : require

#include <renderer/camera>
#include <renderer/instances>
#include <renderer/math>
#include <renderer/meshes/mesh_attributes>
#include <renderer/meshes/mesh_data>
#include <renderer/meshes/mesh_indices>
#include <renderer/meshes/mesh_table>
#include <renderer/transform>
#include <visibility/visibility_buffer>
#include <visibility/visibility_utils>

layout(binding = 0, r8) uniform restrict readonly image2D t_InShadow;
layout(binding = 1, r8) uniform restrict readonly image2D t_InShadowMean;
layout(binding = 2, r8) uniform restrict readonly image2D t_InHistory;
layout(binding = 3, rg16f) uniform restrict writeonly image2D t_OutShadowMoments;

layout(binding = 4, r8) uniform restrict image2D t_InDisocclusionMask;
layout(binding = 5, rg8) uniform restrict image2D t_InMotionVectors;

layout(binding = 7, r8ui) uniform restrict uimage2D t_InOutHistorySamplesCount;

layout(binding = 8, r8) uniform restrict writeonly image2D t_OutFiltered;
layout(binding = 9, rg32ui) uniform restrict readonly uimage2D t_InVisibilityBuffer;

layout(binding = 16) uniform b_CameraBuffer
{
    camera_buffer g_Camera;
};

layout(push_constant) uniform c_PushConstants
{
    float temporalAccumulationFactor;
}
g_Constants;

// We run 8x8 groups
const uint g_ThreadLocalSize = 8;

layout(local_size_x = g_ThreadLocalSize, local_size_y = g_ThreadLocalSize, local_size_z = 1) in;

ivec2 apply_offset_clamp(in ivec2 pixel, in uvec2 offset, in uvec2 resolution)
{
    return ivec2(min(int(resolution.x), int(pixel.x + offset.x)), min(int(resolution.y), int(pixel.y + offset.y)));
}

ivec2 reproject_coords(in ivec2 coords, in uvec2 resolution)
{
    // Motion vectors are calculated as current - previous, so we need to subtract to obtain the previous coordinates
    const vec2 motionVector = imageLoad(t_InMotionVectors, coords).xy;
    const ivec2 pixelOffset = ivec2(resolution * motionVector + .5f);
    return coords - pixelOffset;
}

void main()
{
    const uvec2 resolution = imageSize(t_InShadow);
    const uvec2 screenPos = gl_GlobalInvocationID.xy;

    if (screenPos.x >= resolution.x || screenPos.y >= resolution.y)
    {
        return;
    }

    const float shadow = imageLoad(t_InShadow, ivec2(screenPos)).x;
    const float mean = imageLoad(t_InShadowMean, ivec2(screenPos)).x;

    // TODO: If the mean is 0 or 1 for whole whole group, we might also skip the filtering
    // Note: we use the E[X] instead of E[X^2] because we assume 1 ray per pixel, and shadows are either 0 or 1
    const float mean2 = mean * mean;
     float variance = saturate(mean - mean2);

    vec3 currentPositionWS;
    vec3 lastFramePositionWS;

    const ivec2 historyCoords = reproject_coords(ivec2(screenPos), resolution);

    float history = 0.f;
    uint historySamplesCount = 0;
    float historyWeight = 0.f;

    if (historyCoords.x >= 0 && historyCoords.x < resolution.x && historyCoords.y >= 0 &&
        historyCoords.y < resolution.y)
    {
        const float disocclusion = imageLoad(t_InDisocclusionMask, historyCoords).x;

        if (disocclusion < .9f)
        {
            history = imageLoad(t_InHistory, historyCoords).x;
            historySamplesCount = imageLoad(t_InOutHistorySamplesCount, historyCoords).x;
            historyWeight = g_Constants.temporalAccumulationFactor;
        }

        if (historySamplesCount > 16 && variance > 1e-4)
        {
            const float highVarianceBoost = 5.f;
            const float highVarianceHistoryBoost = 5.f;
            variance *= highVarianceBoost;
            historyWeight = min(highVarianceHistoryBoost * historyWeight, 1.f);
        }
    }

    const float deviation = sqrt(variance);
    const float hDeviation = .5f * deviation;

    const float nmin = mean - hDeviation;
    const float nmax = mean + hDeviation;

    const float clampedHistory = clamp(history, nmin, nmax);

    const float result = mix(shadow, clampedHistory, historyWeight);

    imageStore(t_OutFiltered, ivec2(screenPos), vec4(result, 0, 0, 1));

    const uint newSamples = max(historySamplesCount + 1, 255);
    imageStore(t_InOutHistorySamplesCount, ivec2(screenPos), uvec4(newSamples, 0, 0, 0));

    imageStore(t_OutShadowMoments, ivec2(screenPos), vec4(mean, mean2, 0, 0));
}