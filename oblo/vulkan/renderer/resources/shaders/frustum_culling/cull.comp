#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_buffer_reference : require
#extension GL_ARB_gpu_shader_int64 : require

#include <renderer/camera>
#include <renderer/intersection>
#include <renderer/meshes>

layout(local_size_x = OBLO_SUBGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

struct vk_draw_indirect_command
{
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

struct vk_draw_indexed_indirect_command
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

#ifndef DRAW_INDEXED
#define draw_command_t vk_draw_indirect_command
#else
#define draw_command_t vk_draw_indexed_indirect_command
#endif

layout(binding = 0) uniform b_CullingConfig
{
    uint g_numberOfDraws;
};

layout(binding = 1) uniform b_CameraBuffer
{
    camera_buffer g_Camera;
};

layout(std430, binding = 5) restrict readonly buffer b_InDrawCallsBuffer
{
    draw_command_t inDrawCalls[];
};

layout(std430, binding = 6) restrict buffer b_OutDrawCallsBuffer
{
    draw_command_t outDrawCalls[];
};

void main()
{
    const uint index = gl_GlobalInvocationID.x;

    if (index >= g_numberOfDraws)
    {
        return;
    }

    const mesh_handle meshHandle = g_MeshHandles[index];

    const mesh_table table = get_mesh_table(meshHandle);
    const uint meshIndex = get_mesh_index(meshHandle);

    const aabb box = get_mesh_aabb(table, meshIndex);

    draw_command_t drawCmd = inDrawCalls[index];

    frustum f = g_Camera.frustum;

    drawCmd.instanceCount = intersects_or_contains(f, box) ? 1 : 0;

    outDrawCalls[index] = drawCmd;
}